install.packages("roxygen2")
RETURN
<RETURN>
library(LiPAnalyzer)
?ExtractDataFromSpectro
?RunModel
?lm
library(LiPAnalyzer)
?RunModel
?lm
library(LiPAnalyzer)
?AnalyzeLiPPepData
?lm
?bvls
library(bvls)
?bvls
#' \\code{AnalyzeLiPPepData}\\code{AnalyzeTrpPepData}\\code{AnalyzeTrpProtData}.
#' @param evalCovariable a character giving name of columns in which coefficients and
#' P values of the variable of interest can be found.
#' Default is set to 'Condition_OLS'.
#' @correctPval a character defining how p-values should be adjusted.
#' Per default all p-values are corrected together, and it is set to 'all'.
#' Alternatively, FDR can be perfomred protein-wise, please set the variable to
#''protein-wise' for this.
#' @pAdjust
#'
?p.adjust
?setNames
?as.formula
?bvls
?get.vats
?get.vars
?c
?contr.sum
?contrasts
?model.matrix
?setNames
if(!require("reshape2")) install.packages("reshape2")
if(!require("wec")) install.packages("wec")
library(reshape2)
library(wec)
if(!require("reshape2")) install.packages("reshape2")
if(!require("wec")) install.packages("wec")
?assign
?scale_color_manual
?element_text
library(LiPAnalyzer)
library(LiPAnalyzer)
#' @param infoProtein a character string providing column name of \code{annotPP} where
#' protein names/groups are noted. If \code{correctPval} is defines as 'protein-wise'
#' peptides with the same \code{infoProtein} value will be corrected together
#' Default is set to 'Protein'.
#'
#' @return returns a data.frame including all features of the model and
#' the corresponding coefficients, P values and adjusted P values.
#'
#' @export
#'
SummarizeModelResults <- function(resModel, evalCovariable = "Condition_OLS", correctPval = "all",
pAdjust = "fdr", annotPP = NULL, infoFeature = "Peptide", infoProtein = "Protein"){
modelCoef <- stats::setNames(resModel[[1]][, evalCovariable], row.names(resModel[[1]]))
modelPval <- stats::setNames(resModel[[2]][, evalCovariable], row.names(resModel[[2]]))
if(correctPval == "all"){
modelPvalAdj <- stats::p.adjust(modelPval, method = pAdjust)
}
else if(correctPval == "protein-wise"){
message("Preforming protein-wise FDR correction.")
modelPvalAdj <- DoProteinWiseFDR(modelPval, pAdjust, annotPP, infoFeature, infoProtein)
}
else{
stop("No valid option choosen for correctPval. Please set correctPval to 'all' or 'protein-wise'.\n")
}
modelSum <- data.frame(Coefficient = modelCoef[order(modelPvalAdj, decreasing = T)],
Pvalue = modelPval[order(modelPvalAdj, decreasing = T)],
Padj = modelPvalAdj[order(modelPvalAdj, decreasing = T)])
return(modelSum)
}
DoProteinWiseFDR <- function(vecPval, pAdjust, annotPP, infoFeature, infoProtein){
if(is.null(annotPP)){
stop("Please provide peptide and protein annotations in form of the annotPP matrix./n")
}
if(length(intersect(names(vecPval), annotPP[,infoFeature]))==0){
stop("Please provide correct level on which the models were build. This level must be a column name in the annotPP file./n")
}
matchPepProt <- annotPP[match(names(vecPval), annotPP[,infoFeature]),]
listPval <- split(vecPval, matchPepProt[, infoProtein])
vecAdj <- unlist(lapply(listPval, function(x){
x <- stats::p.adjust(x, method = pAdjust)
return(x)
}))
## Check names of vecAdjust, pot. remove .*[[.[]]]
return(vecAdj)
}
library(LiPAnalyzer)
library(LiPAnalyzer)
## Check names of vecAdjust, pot. remove .*[[.[]]]
print(head(vecAdj))
DoProteinWiseFDR <- function(vecPval, pAdjust, annotPP, infoFeature, infoProtein){
if(is.null(annotPP)){
stop("Please provide peptide and protein annotations in form of the annotPP matrix.\n")
}
if(length(intersect(names(vecPval), annotPP[,infoFeature]))==0){
stop("Please provide correct level on which the models were build. This level must be a column name in the annotPP file.\n")
}
matchPepProt <- annotPP[match(names(vecPval), annotPP[,infoFeature]),]
listPval <- split(vecPval, matchPepProt[, infoProtein])
vecAdj <- unlist(lapply(listPval, function(x){
x <- stats::p.adjust(x, method = pAdjust)
return(x)
}))
## Check names of vecAdjust, pot. remove .*[[.[]]]
print(head(vecAdj))
return(vecAdj)
}
library(LiPAnalyzer)
DoProteinWiseFDR <- function(vecPval, pAdjust, annotPP, infoFeature, infoProtein){
if(is.null(annotPP)){
stop("Please provide peptide and protein annotations in form of the annotPP matrix.\n")
}
if(length(intersect(names(vecPval), annotPP[,infoFeature]))==0){
stop("Please provide correct level on which the models were build. This level must be a column name in the annotPP file.\n")
}
matchPepProt <- annotPP[match(names(vecPval), annotPP[,infoFeature]),]
listPval <- split(vecPval, matchPepProt[, infoProtein])
vecAdj <- unlist(lapply(listPval, function(x){
x <- stats::p.adjust(x, method = pAdjust)
return(x)
}), use.names = F)
## Check names of vecAdjust, pot. remove .*[[.[]]]
print(head(vecAdj))
return(vecAdj)
}
library(LiPAnalyzer)
DoProteinWiseFDR <- function(vecPval, pAdjust, annotPP, infoFeature, infoProtein){
if(is.null(annotPP)){
stop("Please provide peptide and protein annotations in form of the annotPP matrix.\n")
}
if(length(intersect(names(vecPval), annotPP[,infoFeature]))==0){
stop("Please provide correct level on which the models were build. This level must be a column name in the annotPP file.\n")
}
matchPepProt <- annotPP[match(names(vecPval), annotPP[,infoFeature]),]
listPval <- split(vecPval, matchPepProt[, infoProtein])
vecAdj <- unlist(lapply(listPval, function(x){
x <- stats::p.adjust(x, method = pAdjust)
return(x)
}), use.names = F)
names(vecAdj) <- unlist(lapply(listPval, function(x){
names(x)
}))
## Check names of vecAdjust, pot. remove .*[[.[]]]
print(head(vecAdj))
return(vecAdj)
}
library(LiPAnalyzer)
#' @param infoProtein a character string providing column name of \code{annotPP} where
#' protein names/groups are noted. If \code{correctPval} is defines as 'protein-wise'
#' peptides with the same \code{infoProtein} value will be corrected together
#' Default is set to 'Protein'.
#'
#' @return returns a data.frame including all features of the model and
#' the corresponding coefficients, P values and adjusted P values.
#'
#' @export
#'
SummarizeModelResults <- function(resModel, evalCovariable = "Condition_OLS", correctPval = "all",
pAdjust = "fdr", annotPP = NULL, infoFeature = "Peptide", infoProtein = "Protein"){
modelCoef <- stats::setNames(resModel[[1]][, evalCovariable], row.names(resModel[[1]]))
modelPval <- stats::setNames(resModel[[2]][, evalCovariable], row.names(resModel[[2]]))
if(correctPval == "all"){
modelPvalAdj <- stats::p.adjust(modelPval, method = pAdjust)
}
else if(correctPval == "protein-wise"){
message("Preforming protein-wise FDR correction.")
modelPvalAdj <- DoProteinWiseFDR(modelPval, pAdjust, annotPP, infoFeature, infoProtein)
}
else{
stop("No valid option choosen for correctPval. Please set correctPval to 'all' or 'protein-wise'.\n")
}
modelSum <- data.frame(Coefficient = modelCoef[row.name(modelPvalAdj)[order(modelPvalAdj, decreasing = F)]],
Pvalue = modelPval[row.name(modelPvalAdj)[order(modelPvalAdj, decreasing = F)]],
Padj = modelPvalAdj[row.name(modelPvalAdj)[order(modelPvalAdj, decreasing = F)]])
return(modelSum)
}
library(LiPAnalyzer)
DoProteinWiseFDR <- function(vecPval, pAdjust, annotPP, infoFeature, infoProtein){
if(is.null(annotPP)){
stop("Please provide peptide and protein annotations in form of the annotPP matrix.\n")
}
if(length(intersect(names(vecPval), annotPP[,infoFeature]))==0){
stop("Please provide correct level on which the models were build. This level must be a column name in the annotPP file.\n")
}
matchPepProt <- annotPP[match(names(vecPval), annotPP[,infoFeature]),]
listPval <- split(vecPval, matchPepProt[, infoProtein])
vecAdj <- unlist(lapply(listPval, function(x){
x <- stats::p.adjust(x, method = pAdjust)
return(x)
}), use.names = F)
names(vecAdj) <- unlist(lapply(listPval, function(x){
names(x)
}))
vecAdj <- vecAdj[names(vecPval)]
return(vecAdj)
}
library(LiPAnalyzer)
library(LiPAnalyzer)
library(LiPAnalyzer)
# Running BVLS, returning residuals and coeff
RunBVLS <- function(formula, modelMat, lowBVLS, upBVLS, addBVLSbounds){
# bvls does not take -Inf as an input
# change -Inf to high negative number instead
lowBVLS[lowBVLS == -Inf] <- -1e9
# run BVLS models
modelRes <- lapply(modelMat, function(data){
### Add progress bar
Y <- data$Y
X <- data$X
print(data)
# if set to true, adding as many as necessary -Inf and Inf to the
# boundaries of the BVLS
if(addBVLSbounds){
nX <- ncol(X)
lowRep <- nX-length(lowBVLS)
lowBVLS <- c(lowBVLS, rep(-1e9, lowRep))
upRep <- nX-length(upBVLS)
upBVLS <- c(upBVLS, rep(Inf, upRep))
}
# running BVLS
BVLS <- bvls::bvls(A=X,
b=Y,
bl= lowBVLS,
bu=upBVLS)
## Add variable and sample annotation to BVLS output
varsBVLS <- paste0(dimnames(X)[[2]], "_BVLS")
varsBVLS[1] <- "Intercept_BVLS"
attr(BVLS, "variables") <- varsBVLS
attr(BVLS, "samples") <- attributes(X)$samples
return(BVLS)
})
return(modelRes)
}
library(LiPAnalyzer)
library(LiPAnalyzer)
library(LiPAnalyzer)
library(LiPAnalyzeR)
library(LiPAnalyzer)
library(LiPAnalyzeR)
library(LiPAnalyzeR)
